{
  "version": 3,
  "sources": ["../../node_modules/immer/src/patches.js", "../../node_modules/immer/src/common.js", "../../node_modules/immer/src/proxy.js", "../../node_modules/immer/src/es5.js", "../../node_modules/immer/src/immer.js", "../../node_modules/use-immer/src/index.ts"],
  "sourcesContent": ["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue\n                ? \"replace\"\n                : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                    ? {op: \"add\", path, value: origValue}\n                    : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            const path = patch.path.slice()\n            const key = path.pop()\n            const base = path.reduce((current, part) => {\n                if (!current)\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            patch.path.join(\"/\")\n                    )\n                return current[part]\n            }, draft)\n            if (!base)\n                throw new Error(\n                    \"Cannot apply patch, path doesn't resolve: \" +\n                        patch.path.join(\"/\")\n                )\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n", "import {generatePatches} from \"./patches\"\n\nexport const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function original(value) {\n    if (value && value[PROXY_STATE]) {\n        return value[PROXY_STATE].base\n    }\n    // otherwise return undefined\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n", "\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop)\n            ? state.proxies\n            : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n", "\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n", "export {setAutoFreeze, setUseProxies, original} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies, NOTHING} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined\n            ? baseState\n            : normalizeResult(returnValue)\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return normalizeResult(\n        getUseProxies()\n            ? produceProxy(baseState, producer, patchListener)\n            : produceEs5(baseState, producer, patchListener)\n    )\n}\n\nfunction normalizeResult(result) {\n    return result === NOTHING ? undefined : result\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport const nothing = NOTHING\n", "import produce, { Draft, nothing } from \"immer\";\nimport { useState, useReducer, useCallback, useMemo, Dispatch } from \"react\";\n\nexport type Reducer<S = any, A = any> = (\n  draftState: Draft<S>,\n  action: A\n) => void | S | (S extends undefined ? typeof nothing : never);\n\nexport type Updater<S> = (f: (draft: Draft<S>) => void | S) => void;\n\nexport type ImmerHook<S> = [S, Updater<S>];\n\nexport function useImmer<S = any>(\n  initialValue: S | (() => S)\n): [S, (f: ((draft: Draft<S> | S) => void) | S) => void];\n\nexport function useImmer(initialValue: any) {\n  const [val, updateValue] = useState(initialValue);\n  return [\n    val,\n    useCallback(updater => {\n      if(typeof updater === \"function\")\n        updateValue(produce(updater));\n      else\n        updateValue(updater);\n    }, [])\n  ];\n}\n\nexport function useImmerReducer<S = any, A = any>(\n  reducer: Reducer<S, A>,\n  initialState: S,\n  initialAction?: (initial: any) => S\n): [S, Dispatch<A>];\nexport function useImmerReducer(reducer: any, initialState: any, initialAction: any) {\n  const cachedReducer = useMemo(() => produce(reducer), [reducer]);\n  return useReducer(cachedReducer, initialState as any, initialAction);\n}\n"],
  "mappings": "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",
  "names": ["generatePatches", "state", "basepath", "patches", "inversePatches", "baseValue", "resultValue", "Array", "isArray", "generateArrayPatches", "generateObjectPatches", "shared", "Math", "min", "length", "i", "assigned", "path", "concat", "push", "op", "value", "key", "assignedValue", "origValue", "applyPatches", "draft", "patch", "slice", "pop", "base", "reduce", "current", "part", "Error", "join", "NOTHING", "Symbol", "PROXY_STATE", "RETURNED_AND_MODIFIED_ERROR", "verifyMinified", "inProduction", "process", "name", "autoFreeze", "useProxies", "Proxy", "Reflect", "getUseProxies", "useProxies", "isProxy", "value", "PROXY_STATE", "isProxyable", "Array", "isArray", "proto", "Object", "getPrototypeOf", "prototype", "freeze", "autoFreeze", "assign", "Object", "target", "value", "key", "has", "shallowCopy", "Array", "isArray", "slice", "__proto__", "undefined", "create", "each", "cb", "i", "length", "thing", "prop", "prototype", "hasOwnProperty", "call", "finalize", "base", "path", "patches", "inversePatches", "isProxy", "state", "PROXY_STATE", "modified", "finalized", "copy", "result", "finalizeObject", "useProxies", "generatePatches", "assigned", "concat", "freeze", "finalizeNonProxiedObject", "parent", "isProxyable", "isFrozen", "child", "is", "x", "y", "proxies", "objectTraps", "source", "Reflect", "ownKeys", "Error", "arrayTraps", "fn", "arguments", "apply", "deleteProperty", "isNaN", "parseInt", "set", "createState", "get", "createProxy", "getOwnPropertyDescriptor", "owner", "descriptor", "configurable", "defineProperty", "markChanged", "parentState", "proxy", "Proxy", "revocable", "push", "produceProxy", "baseState", "producer", "patchListener", "returnValue", "previousProxies", "rootProxy", "RETURNED_AND_MODIFIED_ERROR", "op", "_", "p", "revoke", "descriptors", "states", "hasCopy", "finalizing", "prepareCopy", "createPropertyProxy", "assertUnfinished", "finished", "JSON", "stringify", "markChangesSweep", "hasArrayChanges", "hasObjectChanges", "markChangesRecursively", "object", "index", "diffKeys", "added", "removed", "from", "to", "a", "keys", "b", "filter", "indexOf", "baseKeys", "shallowEqual", "produceEs5", "prevStates", "objA", "objB", "keysA", "keysB", "createHiddenProperty", "produce", "initialState", "recipe", "args", "currentState", "draft", "normalizeResult", "getUseProxies", "NOTHING", "applyPatches", "applyPatchesImpl", "useImmer", "initialValue", "useState", "updateValue", "f", "useCallback", "updater", "produce", "useImmerReducer", "reducer", "initialState", "initialAction", "cachedReducer", "useMemo", "useReducer"]
}
